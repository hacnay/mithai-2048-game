<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Mithai Merge Mania</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap');
    
    :root {
      --gap: 12px;
      --bg-color: #fef5e7;
      --board-bg: linear-gradient(135deg, #fff8e1 0%, #ffe0b2 100%);
      --tile-bg: #ffe0b2;
      --font-color: #3e2723;
      --font-family: 'Poppins', 'Segoe UI', sans-serif;
      --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.15);
      --shadow-lg: 0 8px 24px rgba(0,0,0,0.2);
      --shadow-xl: 0 12px 40px rgba(0,0,0,0.25);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }

    html {
      height: 100%;
      width: 100%;
      overflow: hidden;
      position: fixed;
      touch-action: none;
      -webkit-overflow-scrolling: touch;
    }

    body {
      background: linear-gradient(135deg, #fef5e7 0%, #ffe0b2 50%, #ffcc80 100%);
      background-attachment: fixed;
      font-family: var(--font-family);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      min-height: 100vh;
      height: 100vh;
      width: 100%;
      position: fixed;
      top: 0;
      left: 0;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-y: contain;
      overscroll-behavior-x: none;
      touch-action: pan-y;
      -webkit-user-select: none;
      user-select: none;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 50%, rgba(255, 193, 7, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 152, 0, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    .container {
      position: relative;
      z-index: 1;
      width: 100%;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
      padding-bottom: 1rem;
    }

    .header {
      text-align: center;
      width: 100%;
      animation: fadeInDown 0.6s ease;
    }

    h1 {
      font-size: clamp(2rem, 5vw, 3rem);
      font-weight: 800;
      color: #5d4037;
      text-shadow: 2px 2px 4px rgba(255,255,255,0.8), 0 0 20px rgba(255,193,7,0.3);
      margin-bottom: 0.5rem;
      letter-spacing: -0.5px;
      background: linear-gradient(135deg, #6d4c41 0%, #8d6e63 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
      width: 100%;
      max-width: 500px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      padding: 1rem;
      border-radius: 1rem;
      box-shadow: var(--shadow-md);
      text-align: center;
      transition: transform 0.2s, box-shadow 0.2s;
      animation: fadeInUp 0.6s ease;
      border: 2px solid rgba(255, 193, 7, 0.2);
    }

    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .stat-label {
      font-size: 0.75rem;
      color: #8d6e63;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #5d4037;
    }

    .challenge-card {
      background: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%);
      backdrop-filter: blur(10px);
      padding: 1rem;
      border-radius: 1rem;
      box-shadow: var(--shadow-md);
      width: 100%;
      text-align: center;
      border: 2px solid rgba(255, 193, 7, 0.3);
      animation: fadeInUp 0.8s ease;
    }

    .challenge-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #5d4037;
      margin-bottom: 0.5rem;
    }

    .progress-bar-container {
      width: 100%;
      height: 12px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 10px;
      overflow: hidden;
      margin-top: 0.5rem;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ffc107 0%, #ff9800 100%);
      border-radius: 10px;
      transition: width 0.5s ease;
      box-shadow: 0 2px 4px rgba(255, 152, 0, 0.4);
      position: relative;
      overflow: hidden;
    }

    .progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 2s infinite;
    }

    .game-container {
      max-width: 450px;
      width: 100%;
      aspect-ratio: 1 / 1;
      background: var(--board-bg);
      padding: var(--gap);
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      grid-gap: var(--gap);
      border-radius: 1.5rem;
      box-shadow: var(--shadow-xl), inset 0 2px 4px rgba(255,255,255,0.5);
      position: relative;
      animation: fadeInUp 1s ease;
      border: 4px solid rgba(255, 193, 7, 0.3);
    }

    .tile {
      width: 100%;
      height: 100%;
      min-width: 0;
      min-height: 0;
      border-radius: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: clamp(0.5rem, 2vw, 0.85rem);
      font-weight: 700;
      color: var(--font-color);
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: inset 0 2px 4px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.1);
      overflow: hidden;
      text-align: center;
      padding: 0.3rem;
      box-sizing: border-box;
      word-wrap: break-word;
      line-height: 1.2;
      position: relative;
      border: 2px solid rgba(255,255,255,0.3);
    }

    .tile:not(.empty):hover {
      transform: scale(1.05);
      box-shadow: inset 0 2px 4px rgba(255,255,255,0.5), 0 4px 8px rgba(0,0,0,0.15);
    }

    .tile.empty {
      background: rgba(255, 255, 255, 0.15);
      border: 2px dashed rgba(255, 193, 7, 0.2);
      box-shadow: none;
    }

    .tile.new {
      animation: popIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .tile.merged {
      animation: mergePulse 0.4s ease;
    }

    .fact-card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 1rem 1.5rem;
      border-radius: 1rem;
      box-shadow: var(--shadow-md);
      width: 100%;
      text-align: center;
      font-size: 0.9rem;
      color: #5d4037;
      line-height: 1.6;
      border: 2px solid rgba(255, 193, 7, 0.2);
      animation: fadeInUp 1.2s ease;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .leaderboard-card {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      padding: 1.5rem;
      border-radius: 1rem;
      box-shadow: var(--shadow-md);
      width: 100%;
      border: 2px solid rgba(255, 193, 7, 0.2);
      animation: fadeInUp 1.4s ease;
    }

    .leaderboard-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: #5d4037;
      margin-bottom: 1rem;
      text-align: center;
    }

    #leaderboard-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #leaderboard-list li {
      padding: 0.75rem;
      margin: 0.5rem 0;
      background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 152, 0, 0.1) 100%);
      border-radius: 0.75rem;
      font-weight: 600;
      color: #5d4037;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      box-shadow: var(--shadow-sm);
      transition: transform 0.2s;
    }

    #leaderboard-list li:hover {
      transform: translateX(5px);
    }

    #leaderboard-list li::before {
      content: 'üèÜ';
      font-size: 1.2rem;
    }

    #leaderboard-list li:first-child::before {
      content: 'ü•á';
    }

    #leaderboard-list li:nth-child(2)::before {
      content: 'ü•à';
    }

    #leaderboard-list li:nth-child(3)::before {
      content: 'ü•â';
    }

    #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 248, 225, 0.98);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: clamp(1.2rem, 3vw, 1.8rem);
      color: #5d4037;
      border-radius: 1.5rem;
      z-index: 10;
      padding: 2rem;
      text-align: center;
      box-shadow: inset 0 0 50px rgba(0,0,0,0.1);
      animation: fadeIn 0.5s ease;
    }

    #game-over.show {
      display: flex;
      animation: fadeInScale 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    #game-over-message {
      margin-bottom: 1.5rem;
      font-weight: 700;
      line-height: 1.4;
    }

    #restart-btn {
      margin-top: 1rem;
      padding: 1rem 2rem;
      font-size: 1.1rem;
      font-weight: 700;
      border: none;
      border-radius: 1rem;
      background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
      color: #3e2723;
      cursor: pointer;
      box-shadow: var(--shadow-md);
      transition: all 0.3s ease;
      font-family: var(--font-family);
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
    }

    #restart-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    #restart-btn:hover::before {
      width: 300px;
      height: 300px;
    }

    #restart-btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    #restart-btn:active {
      transform: translateY(0);
    }

    #restart-btn span {
      position: relative;
      z-index: 1;
    }

    .controls-hint {
      margin-top: 1rem;
      font-size: 0.85rem;
      color: #8d6e63;
      text-align: center;
      font-style: italic;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes popIn {
      0% {
        transform: scale(0);
        opacity: 0;
      }
      50% {
        transform: scale(1.1);
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes mergePulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.15);
      }
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(100%);
      }
    }

    @keyframes scorePop {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.2);
      }
    }

    .score-pop {
      animation: scorePop 0.3s ease;
    }

    @media (max-width: 480px) {
      body {
        padding: 0.25rem;
      }

      .container {
        gap: 0.5rem;
      }

      .header h1 {
        font-size: 1.5rem;
        margin-bottom: 0.25rem;
      }

      .stats-container {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
      }

      .stat-card {
        padding: 0.75rem;
      }

      .stat-value {
        font-size: 1.2rem;
      }

      .challenge-card {
        padding: 0.75rem;
      }

      .challenge-title {
        font-size: 0.8rem;
      }

      .game-container {
        max-width: 100%;
        padding: 8px;
        grid-gap: 8px;
        border-radius: 1rem;
      }
      
      .tile {
        font-size: clamp(0.4rem, 2.5vw, 0.65rem);
        padding: 0.15rem;
        border-radius: 0.75rem;
      }

      .fact-card {
        padding: 0.75rem;
        font-size: 0.8rem;
        min-height: 50px;
      }

      .leaderboard-card {
        padding: 1rem;
      }

      .leaderboard-title {
        font-size: 1rem;
      }

      .controls-hint {
        font-size: 0.75rem;
        margin-top: 0.5rem;
      }
    }

    @media (max-height: 700px) {
      .container {
        gap: 0.5rem;
      }

      .header h1 {
        font-size: 1.5rem;
        margin-bottom: 0.25rem;
      }

      .stats-container {
        gap: 0.5rem;
      }

      .stat-card {
        padding: 0.5rem;
      }

      .challenge-card {
        padding: 0.5rem;
      }

      .fact-card {
        padding: 0.5rem;
        font-size: 0.75rem;
        min-height: 40px;
      }

      .leaderboard-card {
        padding: 0.75rem;
      }
    }

    .achievement-badge {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
      color: #3e2723;
      padding: 1rem 1.5rem;
      border-radius: 1rem;
      box-shadow: var(--shadow-lg);
      font-weight: 700;
      z-index: 1000;
      animation: slideInRight 0.5s ease, slideOutRight 0.5s ease 2.5s forwards;
      display: none;
    }

    .achievement-badge.show {
      display: block;
    }

    .bonus-indicator {
      position: fixed;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: none;
      color: #ff6b35;
      padding: 0.5rem 1rem;
      font-weight: 900;
      font-size: 1.3rem;
      z-index: 2000;
      display: none;
      text-align: center;
      pointer-events: none;
      text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.8),
        0 0 10px rgba(255, 107, 53, 0.8),
        0 0 20px rgba(255, 107, 53, 0.6),
        0 0 30px rgba(255, 107, 53, 0.4);
    }

    .bonus-indicator.show {
      display: block;
      animation: bonusPop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), bonusFadeOut 0.3s ease 1.2s forwards;
    }

    @keyframes bonusPop {
      0% {
        transform: translateX(-50%) translateY(-20px) scale(0.8);
        opacity: 0;
      }
      50% {
        transform: translateX(-50%) translateY(-10px) scale(1.1);
      }
      100% {
        transform: translateX(-50%) translateY(0) scale(1);
        opacity: 1;
      }
    }

    @keyframes bonusFadeOut {
      to {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px) scale(0.95);
      }
    }

    .bonus-amount {
      font-size: 2rem;
      margin-top: 0.3rem;
      text-shadow: 
        2px 2px 6px rgba(0, 0, 0, 0.9),
        0 0 15px rgba(255, 107, 53, 1),
        0 0 25px rgba(255, 107, 53, 0.8),
        0 0 35px rgba(255, 107, 53, 0.6);
      font-weight: 900;
      letter-spacing: 2px;
      color: #ff6b35;
    }

    @media (max-width: 480px) {
      .bonus-indicator {
        top: 100px;
        padding: 0.5rem;
        font-size: 1.1rem;
      }
      
      .bonus-amount {
        font-size: 1.6rem;
      }
    }

    @keyframes slideInRight {
      from {
        transform: translateX(200%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOutRight {
      to {
        transform: translateX(200%);
        opacity: 0;
      }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
  </style>
</head>
<body>
  <div class="achievement-badge" id="achievement-badge"></div>
  <div class="bonus-indicator" id="bonus-indicator">
    <div>üéÅ BONUS!</div>
    <div class="bonus-amount" id="bonus-amount">+0</div>
  </div>
  
  <div class="container">
    <div class="header">
      <h1>üç¨ Mithai Merge Mania üç¨</h1>
    </div>

    <div class="stats-container">
      <div class="stat-card">
        <div class="stat-label">Score</div>
        <div class="stat-value" id="score-display">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Moves</div>
        <div class="stat-value" id="move-counter">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Best Score</div>
        <div class="stat-value" id="best-score-display">0</div>
      </div>
    </div>

    <div class="challenge-card">
      <div class="challenge-title" id="challenge">üéØ Daily Challenge: Loading...</div>
      <div id="challenge-progress-text" style="font-size: 0.85rem; color: #6d4c41; margin-top: 0.5rem;">Progress: 0 / 0</div>
      <div class="progress-bar-container">
        <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
      </div>
    </div>

  <div class="game-container" id="game-board">
    <div id="game-over">
        <div id="game-over-message">üò¢ Out of sweets!<br>Come back tomorrow for more mithai magic!</div>
        <button id="restart-btn"><span>üîÑ New Game</span></button>
      </div>
    </div>

    <div class="fact-card" id="sweet-fact">
      üç¨ Swipe or use arrow keys to merge mithai and unlock sweet facts!
  </div>

    <div class="leaderboard-card">
      <div class="leaderboard-title">üíØ Top Mithai Masters</div>
    <ol id="leaderboard-list"></ol>
    </div>

    <div class="controls-hint">
      Use arrow keys or swipe to play
    </div>
  </div>

  <script>
    const mithaiNames = {
      2: 'Boondi', 4: 'Motichoor', 8: 'Barfi', 16: 'Kaju Katli',
      32: 'Rasgulla', 64: 'Gulab Jamun', 128: 'Rasmalai',
      256: 'Jalebi', 512: 'Ghewar', 1024: 'Gulkand', 2048: 'Thali'
    };

    const mithaiColors = {
      2: 'linear-gradient(135deg, #fbeec1 0%, #f3d250 100%)',
      4: 'linear-gradient(135deg, #f3d250 0%, #f0b64c 100%)',
      8: 'linear-gradient(135deg, #f0b64c 0%, #ec9f4a 100%)',
      16: 'linear-gradient(135deg, #ec9f4a 0%, #e27d60 100%)',
      32: 'linear-gradient(135deg, #e27d60 0%, #c38d9e 100%)',
      64: 'linear-gradient(135deg, #c38d9e 0%, #85cdca 100%)',
      128: 'linear-gradient(135deg, #85cdca 0%, #41b3a3 100%)',
      256: 'linear-gradient(135deg, #41b3a3 0%, #e8a87c 100%)',
      512: 'linear-gradient(135deg, #e8a87c 0%, #c38d9e 100%)',
      1024: 'linear-gradient(135deg, #c38d9e 0%, #8ee4af 100%)',
      2048: 'linear-gradient(135deg, #8ee4af 0%, #4ecdc4 100%)'
    };

    const sweetFacts = [
    "Boondi is made from chickpea flour and is a crucial ingredient in making both sweet and savory ladoos.",
    "Motichoor laddoos are famous for their tiny, delicate boondi pearls, often prepared during special occasions like weddings and festivals.",
    "Barfi is a soft, milk-based sweet that comes in various flavors like chocolate, pistachio, and mango.",
    "Kaju Katli, one of India's most popular sweets, is made by blending cashew nuts with sugar syrup and cardamom, creating a smooth, melt-in-your-mouth texture.",
    "Rasgulla, originally from Bengal, is made from chhena (cottage cheese) and soaked in a light, sugary syrup, creating a spongy, soft dessert.",
    "Gulab Jamun is made from milk solids and flour, deep-fried, and then soaked in a fragrant sugar syrup flavored with rose water or cardamom.",
    "Rasmalai is a creamy dessert made from soft white cream and chhena, flavored with cardamom and saffron, often served chilled.",
    "Jalebi, a crispy, syrupy treat, is made by deep-frying a batter in circular shapes and then soaking it in sugar syrup, making it crispy on the outside and soft on the inside.",
    "Ghewar is a delicate, honeycomb-like dessert from Rajasthan, often served during Teej or Raksha Bandhan festivals. It is soaked in sugar syrup and topped with dry fruits.",
    "Gulkand, a sweet preserve of rose petals and sugar, is not only delicious but is believed to have cooling properties and health benefits, often used in desserts like kulfi and lassi.",
      "Thali is not just a meal but an experience that often ends with a variety of sweets like rasgulla, jalebi, or gulab jamun, making it a perfect finale to a festive feast."
    ];

    const scoreDisplay = document.getElementById("score-display");
    const challengeBox = document.getElementById("challenge");
    const factBox = document.getElementById("sweet-fact");
    const moveCounter = document.getElementById("move-counter");
    const gameOverBox = document.getElementById("game-over");
    const restartBtn = document.getElementById("restart-btn");
    const leaderboardList = document.getElementById("leaderboard-list");
    const board = document.getElementById("game-board");
    const challengeProgressText = document.getElementById("challenge-progress-text");
    const progressBar = document.getElementById("progress-bar");
    const achievementBadge = document.getElementById("achievement-badge");
    const bestScoreDisplay = document.getElementById("best-score-display");
    const bonusIndicator = document.getElementById("bonus-indicator");
    const bonusAmount = document.getElementById("bonus-amount");

    let grid = Array(4).fill(null).map(() => Array(4).fill(0));
    let moveCount = 0;
    let score = 0;
    let mergeCounts = {};
    let targetReached = false;
    let startX, startY;
    let comboCount = 0;
    let lastMoveMerges = 0;

    const challengeOptions = Object.entries(mithaiNames);
    const today = new Date().toDateString();
    const randomIndex = [...today].reduce((acc, char) => acc + char.charCodeAt(0), 0) % challengeOptions.length;
    const [targetValue, targetName] = challengeOptions[randomIndex];
    const targetAmount = (randomIndex % 3 + 2);
    challengeBox.textContent = `üéØ Daily Challenge: Merge ${targetAmount} ${targetName}s!`;
    updateChallengeProgress(0);

    function updateScore() {
      scoreDisplay.textContent = score.toLocaleString();
      scoreDisplay.classList.add('score-pop');
      setTimeout(() => scoreDisplay.classList.remove('score-pop'), 300);
    }


    function showAchievement(message) {
      achievementBadge.textContent = message;
      achievementBadge.classList.add('show');
      setTimeout(() => {
        achievementBadge.classList.remove('show');
      }, 3000);
    }

    function showBonus(bonusPoints, comboCount) {
      bonusAmount.textContent = `+${bonusPoints.toLocaleString()}`;
      if (comboCount > 1) {
        bonusIndicator.querySelector('div:first-child').textContent = `üî• ${comboCount}x COMBO BONUS!`;
      } else {
        bonusIndicator.querySelector('div:first-child').textContent = 'üéÅ BONUS!';
      }
      bonusIndicator.classList.add('show');
      setTimeout(() => {
        bonusIndicator.classList.remove('show');
      }, 1500);
    }

    function spawnTile() {
      let empty = [];
      grid.forEach((row, r) => {
        row.forEach((val, c) => {
          if (val === 0) empty.push([r, c]);
        });
      });
      if (empty.length === 0) return;
      const [r, c] = empty[Math.floor(Math.random() * empty.length)];
      grid[r][c] = Math.random() < 0.9 ? 2 : 4;
      drawBoard();
    }

    function drawBoard() {
      board.querySelectorAll('.tile').forEach(t => t.remove());
      grid.forEach((row) => {
        row.forEach((val) => {
          const tile = document.createElement('div');
          tile.classList.add('tile');
          if (val !== 0) {
            tile.textContent = mithaiNames[val] || val;
            tile.style.background = mithaiColors[val] || '#ffe0b2';
            tile.classList.add('new');
          } else {
            tile.classList.add('empty');
          }
          board.appendChild(tile);
        });
      });
    }

    function slide(row) {
      let arr = row.filter(val => val);
      let merged = Array(4).fill(false);
      
      for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] === arr[i + 1] && !merged[i]) {
          arr[i] *= 2;
          arr[i + 1] = 0;
          merged[i] = true;
          lastMoveMerges++; // Track total merges in this move
          
          // Calculate score with combo bonus
          let baseScore = arr[i];
          let comboMultiplier = lastMoveMerges > 1 ? 1 + (lastMoveMerges - 1) * 0.3 : 1;
          let finalScore = Math.floor(baseScore * comboMultiplier);
          let bonusPoints = finalScore - baseScore;
          
          score += finalScore;
          updateScore();
          
          // Show bonus indicator if bonus was earned
          if (bonusPoints > 0) {
            showBonus(bonusPoints, lastMoveMerges);
          }
          
          // Update merge count first, then check challenge progress
          mergeCounts[arr[i]] = (mergeCounts[arr[i]] || 0) + 1;
          updateChallengeProgress(arr[i]);
          
          if (arr[i] === 2048 && !window.hasWon) {
            window.hasWon = true;
            setTimeout(() => showAchievement("üéâ You've unlocked the Thali! You're a Mithai Master!"), 200);
          }
          triggerSweetFact();
        }
      }
      return arr.filter(val => val).concat(Array(4 - arr.filter(val => val).length).fill(0));
    }

    function move(dir) {
      let rotated = false;
      lastMoveMerges = 0; // Reset merge count for this move
      
      if (dir === 'up' || dir === 'down') {
        grid = grid[0].map((_, i) => grid.map(row => row[i]));
        rotated = true;
      }
      if (dir === 'right' || dir === 'down') {
        grid = grid.map(row => row.reverse());
      }
      let newGrid = grid.map(row => slide(row));
      if (dir === 'right' || dir === 'down') {
        newGrid = newGrid.map(row => row.reverse());
      }
      if (rotated) {
        newGrid = newGrid[0].map((_, i) => newGrid.map(row => row[i]));
      }
      if (JSON.stringify(grid) !== JSON.stringify(newGrid)) {
        grid = newGrid;
        
        // Check for combo (multiple merges in one move)
        if (lastMoveMerges > 1) {
          comboCount++;
          if (comboCount >= 2) {
            showAchievement(`üî• ${lastMoveMerges}x Combo! Amazing!`);
          }
        } else {
          comboCount = 0;
        }
        
        spawnTile();
        moveCount++;
        updateMoveCounter();
        if (isGameOver()) showGameOver();
      } else {
        // Provide feedback for invalid moves
        board.style.animation = 'none';
        setTimeout(() => {
          board.style.animation = 'shake 0.3s ease';
        }, 10);
        comboCount = 0;
      }
    }

    function updateMoveCounter() {
      moveCounter.textContent = moveCount.toLocaleString();
    }

    function triggerSweetFact() {
      const fact = sweetFacts[Math.floor(Math.random() * sweetFacts.length)];
      factBox.textContent = "üç¨ " + fact;
      factBox.style.animation = 'none';
      setTimeout(() => {
        factBox.style.animation = 'fadeInUp 0.5s ease';
      }, 10);
    }

    function updateChallengeProgress(val) {
      mergeCounts[val] = (mergeCounts[val] || 0) + 1;
      if (val == targetValue) {
        const current = mergeCounts[val];
        const progress = Math.min((current / targetAmount) * 100, 100);
        challengeProgressText.textContent = `Progress: ${current} / ${targetAmount}`;
        progressBar.style.width = `${progress}%`;
        
        if (current >= targetAmount && !targetReached) {
          targetReached = true;
          showAchievement("üéØ Challenge Complete! You're a Mithai Champion!");
        }
      }
    }

    function isGameOver() {
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (grid[r][c] === 0) return false;
          if (c < 3 && grid[r][c] === grid[r][c + 1]) return false;
          if (r < 3 && grid[r][c] === grid[r + 1][c]) return false;
        }
      }
      return true;
    }

    function updateLeaderboard() {
      const scores = JSON.parse(localStorage.getItem("mithaiScores") || "[]");
      scores.push(score);
      const sorted = [...new Set(scores)].sort((a, b) => b - a).slice(0, 3);
      localStorage.setItem("mithaiScores", JSON.stringify(sorted));
      leaderboardList.innerHTML = sorted.map(s => `<li>${s.toLocaleString()} points</li>`).join("");
      
      // Update best score display
      const bestScore = sorted.length > 0 ? sorted[0] : 0;
      const currentBest = parseInt(localStorage.getItem("mithaiBestScore") || "0");
      if (score > currentBest) {
        localStorage.setItem("mithaiBestScore", score.toString());
        bestScoreDisplay.textContent = score.toLocaleString();
        bestScoreDisplay.classList.add('score-pop');
        setTimeout(() => bestScoreDisplay.classList.remove('score-pop'), 300);
      } else {
        bestScoreDisplay.textContent = currentBest.toLocaleString();
      }
    }

    function showGameOver() {
      gameOverBox.classList.add('show');
      updateLeaderboard();
    }

    function restartGame() {
      grid = Array(4).fill(null).map(() => Array(4).fill(0));
      moveCount = 0;
      score = 0;
      mergeCounts = {};
      targetReached = false;
      window.hasWon = false;
      comboCount = 0;
      lastMoveMerges = 0;
      gameOverBox.classList.remove('show');
      updateMoveCounter();
      updateScore();
      // Reset challenge progress display
      challengeProgressText.textContent = `Progress: 0 / ${targetAmount}`;
      progressBar.style.width = '0%';
      spawnTile();
      spawnTile();
      drawBoard();
    }

    restartBtn.addEventListener('click', restartGame);

    document.addEventListener('keydown', e => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
        e.preventDefault();
        move(e.key.replace('Arrow', '').toLowerCase());
      }
    });

    board.addEventListener('touchstart', e => {
      e.preventDefault();
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
    }, { passive: false });

    board.addEventListener('touchmove', e => {
      e.preventDefault();
    }, { passive: false });

    board.addEventListener('touchend', e => {
      e.preventDefault();
      if (!startX || !startY) return;
      const dx = e.changedTouches[0].clientX - startX;
      const dy = e.changedTouches[0].clientY - startY;
      const minSwipe = 30;
      
      if (Math.abs(dx) > minSwipe || Math.abs(dy) > minSwipe) {
      if (Math.abs(dx) > Math.abs(dy)) {
        move(dx > 0 ? 'right' : 'left');
      } else {
        move(dy > 0 ? 'down' : 'up');
      }
      }
      startX = null;
      startY = null;
    }, { passive: false });

    // Prevent pull-to-refresh and other unwanted gestures
    document.addEventListener('touchmove', function(e) {
      if (e.target.closest('#game-board')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Prevent zoom on double tap
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        e.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    // Lock screen orientation on mobile (if supported)
    if (screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('portrait').catch(() => {});
    }

    function init() {
      spawnTile();
      spawnTile();
      updateLeaderboard();
      updateScore();
      updateMoveCounter();
      // Load and display best score
      const bestScore = parseInt(localStorage.getItem("mithaiBestScore") || "0");
      bestScoreDisplay.textContent = bestScore.toLocaleString();
    }

    // Wait for Cordova to load (for Android app)
    document.addEventListener('deviceready', function() {
      init();
    }, false);

    // Also run immediately for web version
    if (typeof cordova === 'undefined') {
      init();
    }
  </script>
  <script src="cordova.js"></script>
</body>
</html>
